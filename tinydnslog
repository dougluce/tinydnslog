#!/usr/bin/env python
"""
Reads log files from tinydns and/or dnscache and prints them out in
human-readable form.  Logs can be supplied on stdin, or listed on
the command line:

 # cat @*.s | parse_djbdns_log
 # parse_djbdns_log @*.s
 # tail -f current | parse_djbdns_log

Pipes each log file through tai64nlocal, which must be on your path.

Requirements:
 * tai64nlocal on the path
 * Python 3 or greater

Acknowledgments:

* The log format descriptions by Rob Mayoff were invaluable:
    http://dqd.com/~mayoff/notes/djbdns/tinydns-log.html
    http://dqd.com/~mayoff/notes/djbdns/dnscache-log.html

* Faried Nawaz's dnscache log parser was the original inspiration:
    http://www.hungry.com/~fn/dnscache-log.pl.txt

Written by Greg Ward <gward@python.net> 2001/12/13.

Modified to handle IPv6 addresses (as logged by djbdns with the patch at
http://www.fefe.de/dns/), 2003/05/03-04, prodded and tested by Jakob
Hirsch <jh@plonk.de>.

Modified to handle dnscache's AXFR request log lines by Malte Tancred
(http://tancred.com/malte.html), 2005/12/20.

Basic parse of simple line w/IPv4 address:
>>> parse_logfile(testfile(1))
2024-04-02 13:16:43.372207500 sent response to 69.10.194.146:64182 (id 14256): a luther.con.com

Parsing of two lines w/IPv4 addresses:
>>> parse_logfile(testfile(2))
2024-04-02 13:16:43.372207500 sent response to 69.10.194.146:64182 (id 14256): a luther.con.com
2024-04-02 13:16:43.380039500 sent response to 69.10.194.146:65328 (id 50665): 65 luther.con.com

Parse two lines with IPv6 addresses:
>>> parse_logfile(testfile(3))
2024-04-02 16:38:47.277031500 sent response to [2620:0:cc8::207]:3148 (id 11877): a luther.con.com
2024-04-02 16:38:47.125500500 sent response to [2607:f8b0:4023:1000::102]:40079 (id 13918): 65 luther.con.com

"""

import sys
import re
import subprocess
import argparse
import doctest
import tempfile
import signal

from ipaddress import IPv6Address

# common components of line-matching regexes
timestamp_pat = r"[\d-]+ [\d:\.]+"  # output of tai64nlocal
hex4_pat = r"[0-9a-f]{4}"
ip_pat = r"[0-9a-f]{8,32}"  # IPv4 or IPv6 addresses in hex

# discriminate between dnscache and tinydns log lines
tinydns_log_re = re.compile(
    r"(%s) (%s):(%s):(%s) ([\+\-IC/]) (%s) (.*)"
    % (timestamp_pat, ip_pat, hex4_pat, hex4_pat, hex4_pat)
)
dnscache_log_re = re.compile(r"(%s) (\w+)(.*)" % timestamp_pat)

query_type = {
    1: "a",
    2: "ns",
    5: "cname",
    6: "soa",
    12: "ptr",
    13: "hinfo",
    15: "mx",
    16: "txt",
    17: "rp",
    24: "sig",
    25: "key",
    28: "aaaa",
    38: "a6",
    252: "axfr",
    255: "any",
}

# for tinydns only
query_drop_reason = {
    "-": "no authority",
    "I": "invalid query",
    "C": "invalid class",
}


def convert_ip(ip):
    """Convert a hex string representing an IP address to conventional form."""
    ady = IPv6Address(int(ip, 16))
    if ady < IPv6Address("::ffff:255.255.255.255") and ady > IPv6Address(
        "::ffff:0.0.0.0"
    ):
        return ady.ipv4_mapped
    else:  # ipv6
        return "[%s]" % ady


def _cvt_ip(match):
    return convert_ip(match.group(1))


def _cvt_port(match):
    return ":" + str(int(match.group(1), 16))


def decode_client(words, i):
    chunks = words[i].split(":")
    if len(chunks) == 2:  # ip:port
        words[i] = "%s:%d" % (convert_ip(chunks[0]), int(chunks[1], 16))
    elif len(chunks) == 3:
        words[i] = "%s:%d (id %d)" % (
            convert_ip(chunks[0]),
            int(chunks[1], 16),
            int(chunks[2], 16),
        )


def decode_ip(words, i):
    words[i] = convert_ip(words[i])


def decode_ttl(words, i):
    words[i] = "TTL=%s" % words[i]


def decode_serial(words, i):
    serial = int(words[i])
    words[i] = "#%d" % serial


def decode_type(words, i):
    qt = words[i]
    words[i] = query_type.get(int(qt), qt)


def handle_dnscache_log(line, match):
    (timestamp, event, data) = match.groups()

    words = data.split()
    if event == "cached":
        if words[0] not in ("cname", "ns", "nxdomain"):
            decode_type(words, 0)

    elif event == "drop":
        decode_serial(words, 0)

    elif event == "lame":
        decode_ip(words, 0)

    elif event == "nodata":
        decode_ip(words, 0)
        decode_ttl(words, 1)
        decode_type(words, 2)

    elif event == "nxdomain":
        decode_ip(words, 0)
        decode_ttl(words, 1)

    elif event == "query":
        decode_serial(words, 0)
        decode_client(words, 1)
        decode_type(words, 2)

    elif event == "rr":
        decode_ip(words, 0)
        decode_ttl(words, 1)
        if words[2] not in ("cname", "mx", "ns", "ptr", "soa"):
            decode_type(words, 2)
            if words[2] == "a":  # decode answer to an A query
                decode_ip(words, 4)
            if words[2] == "txt":  # text record
                response = words[4]
                if response.endswith("..."):
                    ellipsis = "..."
                    response = response[0:-3]
                else:
                    ellipsis = ""
                length = int(response[0:2], 16)
                chars = []
                for i in range(1, len(response) / 2):
                    chars.append(chr(int(response[2 * i : (2 * i) + 2], 16)))
                words[4] = '%d:"%s%s"' % (length, "".join(chars), ellipsis)

    elif event == "sent":
        decode_serial(words, 0)

    elif event == "stats":
        words[0] = "count=%s" % words[0]
        words[1] = "motion=%s" % words[1]
        words[2] = "udp-active=%s" % words[2]
        words[3] = "tcp-active=%s" % words[3]

    elif event == "tx":
        words[0] = "g=%s" % words[0]
        decode_type(words, 1)
        # words[2] = name
        # words[3] = control (domain for which these servers are believed
        #            to be authoritative)
        for i in range(4, len(words)):
            decode_ip(words, i)

    elif event in ("tcpopen", "tcpclose"):
        decode_client(words, 0)

    print(timestamp, event, " ".join(words), flush=True)


def handle_tinydns_log(line, match):
    (timestamp, ip, port, id, code, type, name) = match.groups()
    ip = convert_ip(ip)
    port = int(port, 16)
    id = int(id, 16)
    type = int(type, 16)  # "001c" -> 28
    type = query_type.get(type, type)  # 28 -> "aaaa"

    sys.stdout.write(timestamp + " ")
    sys.stdout.flush()

    if code == "+":
        print(
            ("sent response to %s:%s (id %s): %s %s" % (ip, port, id, type, name)),
            flush=True,
        )
    elif code in ("-", "I", "C"):
        reason = query_drop_reason[code]
        print(
            (
                "dropped query (%s) from %s:%s (id %s): %s %s"
                % (reason, ip, port, id, type, name)
            ),
            flush=True,
        )
    elif code == "/":
        print(("dropped query (couldn't parse) from %s:%s" % (ip, port)), flush=True)
    else:
        print(
            ("%s from %s:%s (id %s): %s %s" % (code, ip, port, id, type, name)),
            flush=True,
        )


def parse_logfile(file):
    # Open pipe to tai64nlocal: we will write lines of our input (the
    # raw log file) to it, and read log lines with readable timestamps
    # from it.
    # (tai_stdout, tai_stdin) = popen2("tai64nlocal", 0)
    p = subprocess.Popen(
        "tai64nlocal",
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )

    for line in file:
        p.stdin.write(line.encode())
        p.stdin.flush()
        line = p.stdout.readline().decode()

        match = tinydns_log_re.match(line)
        if match:
            handle_tinydns_log(line, match)
            continue

        match = dnscache_log_re.match(line)
        if match:
            handle_dnscache_log(line, match)
            continue

        sys.stdout.write(line)
        sys.stdout.flush()

def test():
    """
    Creates a test file with some log stuff in it.
    """
    def handler(signum, stack):
        raise Exception('Test timeout')
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(4)

    result = doctest.testmod(verbose=args.verbose,
                             optionflags=doctest.NORMALIZE_WHITESPACE|doctest.ELLIPSIS)
    if result.failed == 0:
        print(f"{result.attempted} successful tests")

def testfile(which):
    tmp = tempfile.TemporaryFile(mode="r+")
    lines = {
        1: # Single line, simple, IPv4
        ['@40000000660c67b5162f6f8c 00000000000000000000ffff450ac292:fab6:37b0 + 0001 luther.con.com'],
        2: # Two lines, simple, IPv4
        ['@40000000660c67b5162f6f8c 00000000000000000000ffff450ac292:fab6:37b0 + 0001 luther.con.com',
         '@40000000660c67b516a6f14c 00000000000000000000ffff450ac292:ff30:c5e9 + 0041 luther.con.com'],
        3: # Two lines, IPv6
        ['@40000000660c971110832a4c 262000000cc800000000000000000207:0c4c:2e65 + 0001 luther.con.com',
         '@40000000660c9711077afc54 2607f8b0402310000000000000000102:9c8f:365e + 0041 luther.con.com']
    }
    tmp.write('\n'.join(lines[which]))
    tmp.write('\n')
    tmp.seek(0)
    return tmp

parser = argparse.ArgumentParser(description="Produce human readable output from TinyDNS logfiles")

parser.add_argument(
    '--input-file', '-i',
    type=argparse.FileType('r'),
    default=sys.stdin,
    help='Input file name containing TinyDNS log output')

parser.add_argument("-t", "--test", help="Run doctests", action="store_true")

parser.add_argument(
    "-v", "--verbose", help="Run doctests verbosely", action="store_true"
)

args = parser.parse_args()

if args.test:
    test()
else:
    parse_logfile(args.input_file)
